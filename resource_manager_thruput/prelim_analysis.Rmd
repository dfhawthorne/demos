---
title: "Preliminary Report on ORM 2k"
author: "Douglas Hawthorne"
date: "12/01/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
raw_data <- read.csv("results.csv")
```

## Overview

This is a preliminary analysis of a $2^k$ experiment done on a Compaq Presario
of the effects of different Oracle Resource Manager (ORM) plans and differing
number of cores on the rate of execution a CPU-intensive SQL statement.

## Data from Test Run

The data from the test runs were extracted from AWR reports collected on
Tuesday 12 January 2021.

```{r raw_data}
raw_data$plan     <- factor(raw_data$plan)
raw_data$num_cpus <- factor(raw_data$num_cpus)
raw_data$X        <- NULL
summary(raw_data)
```
__Note__ There are two (2) factors with a replication of five (5) for each
interaction term. In other words, this is a $2^2$ factorial experiment on:
1. ORM Plan Name
1. Number of CPUs

The response variable is called `rate` which is calculated as the number of
executions of the following SQL statement over the elapsed time between AWR
snapshots:
```sql
SELECT count(*) AS num_items FROM ITEM
```

## Fit ANOVA model

```{r, fit_anova_model}
rate.lm <- aov(rate ~ plan * num_cpus, data=raw_data)
summary.aov(rate.lm)
```

This indicates that all of the factors (ORM plan used and the number of CPUs)
are significant as well as the interaction between them.

```{r, summary_lm}
summary.lm(rate.lm)
```

## Interaction

The interaction can be best visualised as follows:
```{r, interaction}
interaction.plot(plan,num_cpus,rate)
```
As can be readily seen, the execution rate barely differs between the choice
of ORM plans when executing on one (1) CPU. However having six (6) CPUs
available, the `INTERNAL_PLAN` performs better.

We can look at an alternative view of the interaction as follows:
```{r, interaction_2}
interaction.plot(num_cpus,plan,rate)
```

## Checking Residuals

```{r, check_residuals}
shapiro.test(rate.lm$residuals)
```

The residuals are not normally distributed.
